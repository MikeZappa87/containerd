// Code generated by protoc-gen-go-fieldpath. DO NOT EDIT.
// source: services/networking/v1/networking.proto
package networking

import (
	fmt "fmt"
	strings "strings"
)

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *PortMapping) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: container_port
	// unhandled: host_port
	case "protocol":
		return string(m.Protocol), len(m.Protocol) > 0
	case "host_ip":
		return string(m.HostIp), len(m.HostIp) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *DNSConfig) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "servers":
		return string(m.Servers), len(m.Servers) > 0
	case "searches":
		return string(m.Searches), len(m.Searches) > 0
	case "options":
		return string(m.Options), len(m.Options) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *SetupPodNetworkRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: annotations
	// unhandled: port_mappings
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	case "netns_path":
		return string(m.NetnsPath), len(m.NetnsPath) > 0
	case "pod_name":
		return string(m.PodName), len(m.PodName) > 0
	case "pod_namespace":
		return string(m.PodNamespace), len(m.PodNamespace) > 0
	case "pod_uid":
		return string(m.PodUid), len(m.PodUid) > 0
	case "labels":
		// Labels fields have been special-cased by name. If this breaks,
		// add better special casing to fieldpath plugin.
		if len(m.Labels) == 0 {
			return "", false
		}
		value, ok := m.Labels[strings.Join(fieldpath[1:], ".")]
		return value, ok
	case "dns_config":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.DnsConfig == nil {
			return "", false
		}
		return m.DnsConfig.Field(fieldpath[1:])
	case "cgroup_parent":
		return string(m.CgroupParent), len(m.CgroupParent) > 0
	case "prev_result":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.PrevResult == nil {
			return "", false
		}
		return m.PrevResult.Field(fieldpath[1:])
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *SetupPodNetworkResponse) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: interfaces
	// unhandled: routes
	case "dns":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Dns == nil {
			return "", false
		}
		return m.Dns.Field(fieldpath[1:])
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *TeardownPodNetworkRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: annotations
	// unhandled: port_mappings
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	case "netns_path":
		return string(m.NetnsPath), len(m.NetnsPath) > 0
	case "pod_name":
		return string(m.PodName), len(m.PodName) > 0
	case "pod_namespace":
		return string(m.PodNamespace), len(m.PodNamespace) > 0
	case "pod_uid":
		return string(m.PodUid), len(m.PodUid) > 0
	case "labels":
		// Labels fields have been special-cased by name. If this breaks,
		// add better special casing to fieldpath plugin.
		if len(m.Labels) == 0 {
			return "", false
		}
		value, ok := m.Labels[strings.Join(fieldpath[1:], ".")]
		return value, ok
	case "cgroup_parent":
		return string(m.CgroupParent), len(m.CgroupParent) > 0
	case "prev_result":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.PrevResult == nil {
			return "", false
		}
		return m.PrevResult.Field(fieldpath[1:])
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *TeardownPodNetworkResponse) Field(fieldpath []string) (string, bool) {
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *GetPodResourcesRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *GetPodResourcesResponse) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "pod_netns_path":
		return string(m.PodNetnsPath), len(m.PodNetnsPath) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *GetPodIPsRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *PodInterfaceIPs) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "ips":
		return string(m.Ips), len(m.Ips) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *PodRoute) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "destination":
		return string(m.Destination), len(m.Destination) > 0
	case "gateway":
		return string(m.Gateway), len(m.Gateway) > 0
	case "interface_name":
		return string(m.InterfaceName), len(m.InterfaceName) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *GetPodIPsResponse) Field(fieldpath []string) (string, bool) {
	// unhandled: interface_ips
	// unhandled: routes
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *GetPodNetworkRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *NetworkInterface) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: type
	// unhandled: mtu
	case "name":
		return string(m.Name), len(m.Name) > 0
	case "mac_address":
		return string(m.MacAddress), len(m.MacAddress) > 0
	case "state":
		return string(m.State), len(m.State) > 0
	case "addresses":
		return string(m.Addresses), len(m.Addresses) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *RouteEntry) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: metric
	case "destination":
		return string(m.Destination), len(m.Destination) > 0
	case "gateway":
		return string(m.Gateway), len(m.Gateway) > 0
	case "interface_name":
		return string(m.InterfaceName), len(m.InterfaceName) > 0
	case "scope":
		return string(m.Scope), len(m.Scope) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *RoutingRule) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: priority
	case "src":
		return string(m.Src), len(m.Src) > 0
	case "dst":
		return string(m.Dst), len(m.Dst) > 0
	case "table":
		return string(m.Table), len(m.Table) > 0
	case "iif":
		return string(m.Iif), len(m.Iif) > 0
	case "oif":
		return string(m.Oif), len(m.Oif) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *GetPodNetworkResponse) Field(fieldpath []string) (string, bool) {
	// unhandled: interfaces
	// unhandled: routes
	// unhandled: rules
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *MoveDeviceRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: device_type
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	case "device_name":
		return string(m.DeviceName), len(m.DeviceName) > 0
	case "target_name":
		return string(m.TargetName), len(m.TargetName) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *MoveDeviceResponse) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: routes
	// unhandled: rules
	case "device_name":
		return string(m.DeviceName), len(m.DeviceName) > 0
	case "addresses":
		return string(m.Addresses), len(m.Addresses) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *AssignIPAddressRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	case "interface_name":
		return string(m.InterfaceName), len(m.InterfaceName) > 0
	case "address":
		return string(m.Address), len(m.Address) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *AssignIPAddressResponse) Field(fieldpath []string) (string, bool) {
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *ApplyRouteRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	case "route":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Route == nil {
			return "", false
		}
		return m.Route.Field(fieldpath[1:])
	case "host_network":
		return fmt.Sprint(m.HostNetwork), true
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *ApplyRouteResponse) Field(fieldpath []string) (string, bool) {
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *ApplyRuleRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	case "rule":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Rule == nil {
			return "", false
		}
		return m.Rule.Field(fieldpath[1:])
	case "host_network":
		return fmt.Sprint(m.HostNetwork), true
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *ApplyRuleResponse) Field(fieldpath []string) (string, bool) {
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *VethConfig) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "peer_name":
		return string(m.PeerName), len(m.PeerName) > 0
	case "peer_netns_path":
		return string(m.PeerNetnsPath), len(m.PeerNetnsPath) > 0
	case "peer_master":
		return string(m.PeerMaster), len(m.PeerMaster) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *VxlanConfig) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: vni
	// unhandled: port
	// unhandled: ttl
	case "group":
		return string(m.Group), len(m.Group) > 0
	case "underlay_device":
		return string(m.UnderlayDevice), len(m.UnderlayDevice) > 0
	case "local":
		return string(m.Local), len(m.Local) > 0
	case "learning":
		return fmt.Sprint(m.Learning), true
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *BridgeConfig) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: forward_delay
	// unhandled: default_pvid
	case "stp_enabled":
		return fmt.Sprint(m.StpEnabled), true
	case "vlan_filtering":
		return fmt.Sprint(m.VlanFiltering), true
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *DummyConfig) Field(fieldpath []string) (string, bool) {
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *IpvlanConfig) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: mode
	// unhandled: flag
	case "parent":
		return string(m.Parent), len(m.Parent) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *MacvlanConfig) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: mode
	case "parent":
		return string(m.Parent), len(m.Parent) > 0
	case "mac_address":
		return string(m.MacAddress), len(m.MacAddress) > 0
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *CreateNetdevRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	// unhandled: mtu
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	case "name":
		return string(m.Name), len(m.Name) > 0
	case "addresses":
		return string(m.Addresses), len(m.Addresses) > 0
	case "host_network":
		return fmt.Sprint(m.HostNetwork), true
	case "master":
		return string(m.Master), len(m.Master) > 0
	case "veth":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Veth == nil {
			return "", false
		}
		return m.Veth.Field(fieldpath[1:])
	case "vxlan":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Vxlan == nil {
			return "", false
		}
		return m.Vxlan.Field(fieldpath[1:])
	case "dummy":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Dummy == nil {
			return "", false
		}
		return m.Dummy.Field(fieldpath[1:])
	case "ipvlan":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Ipvlan == nil {
			return "", false
		}
		return m.Ipvlan.Field(fieldpath[1:])
	case "macvlan":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Macvlan == nil {
			return "", false
		}
		return m.Macvlan.Field(fieldpath[1:])
	case "bridge":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Bridge == nil {
			return "", false
		}
		return m.Bridge.Field(fieldpath[1:])
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *CreateNetdevResponse) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "interface":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.Interface == nil {
			return "", false
		}
		return m.Interface.Field(fieldpath[1:])
	case "peer_interface":
		// NOTE(stevvooe): This is probably not correct in many cases.
		// We assume that the target message also implements the Field
		// method, which isn't likely true in a lot of cases.
		//
		// If you have a broken build and have found this comment,
		// you may be closer to a solution.
		if m.PeerInterface == nil {
			return "", false
		}
		return m.PeerInterface.Field(fieldpath[1:])
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *AttachInterfaceRequest) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "sandbox_id":
		return string(m.SandboxId), len(m.SandboxId) > 0
	case "interface_name":
		return string(m.InterfaceName), len(m.InterfaceName) > 0
	case "master":
		return string(m.Master), len(m.Master) > 0
	case "host_network":
		return fmt.Sprint(m.HostNetwork), true
	}
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *AttachInterfaceResponse) Field(fieldpath []string) (string, bool) {
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *CheckHealthRequest) Field(fieldpath []string) (string, bool) {
	return "", false
}

// Field returns the value for the given fieldpath as a string, if defined.
// If the value is not defined, the second value will be false.
func (m *CheckHealthResponse) Field(fieldpath []string) (string, bool) {
	if len(fieldpath) == 0 {
		return "", false
	}
	switch fieldpath[0] {
	case "ready":
		return fmt.Sprint(m.Ready), true
	case "message":
		return string(m.Message), len(m.Message) > 0
	}
	return "", false
}
